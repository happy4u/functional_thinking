<!-- $size: 16:9 -->
# 7 실용적 사고 (Practical Thinking)
* 이 장에서는 자바 8에서 시작해서 함수형 구조와 웹 프레임워크까지 함수형 사고가 적용된 실례를 살펴보겠다.

---
## 7.1 자바 8
* 자바 8 언어 설계자들은, 언어에 고계함수를 그냥 덧붙이지 않고, 교모하게 기존의 인터페이스들이 함수형 기능을 사용할 수 있도록 만들었다.
* [예제 7.1]은 2장에서 본 [예제 2-4](https://github.com/happy4u/functional_thinking/tree/master/chapter2#212-함수형-처리---cont-1) '회사 프로세스'를 자바 8 해법으로 보여준다.
* [예제 7.1 자바 8로 만든 회사 프로세스](https://github.com/happy4u/functional_thinking/blob/master/chapter7/7.1_ex_7-1.java)
	* 자바 8의 스트림을 사용하면, collect(), forEach()처럼 출력을 발생하는 함수(종결 작업-terminal operation-이라고 부른다)를 호출할 때까지 다른 함수들을 연결해서 구성할 수 있다.
	* filter() 메서드는 boolean 값을 리턴하는 일급 함수를 받아서 필터 조건으로 사용. 값이 true이면 필터된 컬렉션에 포함 시키고, 값이 false이면 제외시킨다.
	* filter() 메서드는 Predicate\<T\> 자료형을 받는다. 이것은 boolean 값을 리턴하는 메서드이다.

---
## 7.1 자바 8 - cont.
* [예제 7-2 술어의 수동 생성] - 이렇게도 사용이 가능하다는 정도의 예제코드
  ```java
  Predicate<String> p = (name) -> name.startsWith("Mr");
  List<String> l = List.of("Mr Rogers", "Ms Robinson", "Mr Ed");
  l.stream().filter(p).forEach(i -> System.out.println(i));
  ```
  * 필터하는 람다 블록을 사용하여 술어를 생성
* [예제 7.1] 마지막으로 종결 작업인 collect() 메서드를 호출. 이 메서드가 스트림에서 값을 만들어낸다.
* 자바 8에도 reduce() 메서드가 있지만 이 예제 같은 경우에는 StringBuilder와 같은 가변구조에 효과적으로 쓸 수 있는 collect()가 적합하다.
* 자바 8에는 ArrayList나 StringBuilder(가변 구조를 컬렉션)를 위해, 매번 새로운 결과를 내지 않고 기존의 요소를 업데이트하는, 가변 리듀스 작업을 하는 메서드가 포함됨.
* [예제 7-1]의 reduce()도 제대로 작동은 할 테지만, 이 경우에는 collect()가 좀 더 효율적.
* 이 두 차이점을 이해하는 것이 기존의 언어에 이런 복잡한 기능을 더할 때 어쩔 수 없이 생기는 간접 비용이다.

---
### 7.1.1 함수형 인터페이스
* Ruannable이나 Callable같이 매서드 하나만을 가지는 인터페이스는 단일 추상 메서드(SAM (single abstract method))라고 부른다.
* 자바 8에서는 람다 블록으로 이동 가능한 코드를 잘 구현할 수 있다.
* **함수형 인터페이스**라는 영리한 메커니즘은 람다와 SAM이 유용하게 상호작용할 수 있게 해준다.
* 하나의 함수형 인터페이스는 하나의 SAM을 포함하며, 여러 개의 디폴트 메서드도 함께 포함할 수 있다.
* 함수형 인터페이스는 기존 SAM 인터페이스가 전통적 익명 클래스 인스턴스를 람다 블록으로 대체할 수 있게 개선해준다.


---
### 7.1.1 함수형 인터페이스 - cont.
* 람다 블록이 대체 가능함을 보여주는 예로, 자바 8에서는 Runnable 익명 내부 클래스 대신에 람다 블록을 넣어서 쓰레드를 생성할 수 있다.
  ```java
  new Thread(() -> System.out.println("Inside thread")).start();
  ```
  * 함수형 인터페이스는 여러 유용한 상황에서 람다 블록이 자연스럽게 녹아들 수 있게 해준다.
* 자바 8에서는 인터페이스에 **디폴츠 메서드**를 지정할 수 있다. 디폴트 메서드는 인터페이스 안에 default로 표시되는 public, nonabstract, nonstatic (본문이 있는) 메서드이다.
* 모든 디폴트 메서드는 인터페이스를 구현한 모든 클래스에 자동으로 더해진다.
* [Comparator(비교자) 인터페이스](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)는 이제 10개가 넘는 디폴트 메서드를 가지고 있다.

---
### 7.1.1 함수형 인터페이스 - cont.
* [예제 7-3 Comparator 클래스의 디폴트 메서드들]
  ```java
  List<Integer> n = List.of(1, 4, 45, 12, 5, 6, 9, 101);
  Comparator<Integer> c1 = (x, y) -> x - y;
  Comparator<Integer> c2 = c1.reversed();
  System.out.println("Smallest = " + n.stream().min(c1).get());
  System.out.println("Largest = " + n.stream().min(c2).get());
  ```
	* 람다 블록을 감싸는 Comparator 인스턴스를 생성했다.
	* 역 비교자는 reversed() 디폴트 메서드를 호출하면 만들 수 있다.
* 자바 8의 디폴트 메서드는 자바에 믹신(mixin)을 제공한다.
	* mixin : 다른 클래스에서 사용될 메서드를 정의하지만, 그 클래스의 상속 체계에 포함되지 않은 클래스를 지칭한다. 언어마다 구현이나 사용법은 다르지만, 공통적으로 코드의 재사용을 권장하고 다중상속의 모호함을 해결해준다.	 
* 이 덕분에 Arrays나 Collections 같은 클래스들을 JDK에서 없앨 수 있게 된다. 이것들은 적당한 자리를 찾지 못한 정적 메서드의 모임에 불과했기 때문이다.

---
### 7.1.2 옵셔널
* [예제 7-3]에서 스트림 종료 메서드에 따라오는 get()의 호출을 주목하자. 자바 8에서 min()과 같은 내장 메서드는 값 대신 Optional을 리턴한다. 이것은 [5장에서 본 옵션 클래스](https://github.com/happy4u/functional_thinking/tree/master/chapter5#553-옵션-클래스)와 유사하다.
* Optional은 오류로서의 null과 리턴 값으로서의 null을 혼용하는 것을 방지한다.
* 자바 8의 종결 작업은 ifPresent() 메서드를 사용하여 제대로 된 리턴 값에만 코드 블록을 실행하게끔 했다.
* 예를 들어 다음 코드는 값이 있을 때만 결과를 출력한다.
  ```
      n.stream()
          .min((x, y) -> x - y)
          .ifPresent(z -> System.out.println("smallest is " + z));
  ```
* 자바 8의 Comparator 인터페이스를 살펴보면 디폴트 메서드가 얼마나 유용한지 알 수 있다.


---
### 7.1.3 자바 8 스트림
* 자바 8의 스트림은 많은 함수형 기능을 가능하게 한다.
* 스트림은 여러모로 컬렉션과 비슷하지만 다음과 같은 중요한 차이점이 있다.
	* 스트림은 값을 저장하지 않으며, 종결 작업을 통해 입력에서 종착점까지 흐르는 파이프라인처럼 사용된다.
	* 스트림은 상태를 유지하지 않는 함수형으로 설계되었다.
	* 스트림 작업은 최대한 게으르게 한다. ([4장 참조](https://github.com/happy4u/functional_thinking/tree/master/chapter4#42-게으름laziness))
	* 무한한 스트림이 가능하다. 일례로 모든 정수를 리턴하는 스트리을 만들어 limit()이나 findFirst() 같은 메서드를 사용하셔 그 부분집합을 구할 수 있다.
	* Iterator 인스턴스처럼 스트림은 사용과 동시에 소멸되고, 재사용 전에 다시 생성해야 한다.

---
## 7.2 함수형 인프라스트럭처 (Functional Infrastructure)
* 자바 애플리케이션을 조금씩 함수형 구조로 바꾸기 쉽게 해준 덕분에, 익명 내부 클래스를 람다 블록으로 바꾸기는 쉽다.
* 반면에, 소프트웨어 아키텍처나 데이터를 다루는 근본적인 방법을 점진적으로 바꾸기는 훨씬 어렵다.
* 함수형 프로그래밍이 실제 상황에 어떤 영향을 주는지를 살펴보자

---
### 7.2.1 아키텍처
* 함수형 아키텍처는 불변성이 그 중심에 있고, 이를 최대한 사용하려고 시도한다.
* 함수형 프로그래머처럼 사고하려면 불변성을 받아들이는 것이 중요하다.
* 자바에서 불변성 객체를 만들려면 좀 복잡한 선행 작업이 필요하지만, 추상화로 얻게 되는 이점들이 이를 충분히 보상해준다.
* 불변 클래스는 자바에서 주로 걱정해야 하는 것들을 많이 없애준다.
> 가변 상태와 테스트는 직접적인 상호 관계가 있다. 전자가 많으면 후자가 많게 된다.
* 변이를 엄격하게 제한해서 변이점들을 고립시키면 오류가 발생할 장소가 적어지고, 결국 테스트할 곳들이 줄어든다.
* 불변 객체는 자동적으로 스레드 안전하기 때문에 동기화의 문제가 없다.

---
### 7.2.1 아키텍처 - cont.
* 자바 클래스를 불변형으로 만들려면 반드시 다음과 같이 해야 한다.
> 모든 필드를 final로 선언한다.
* final로 선언된 필드들은 선언 시나 생성자 내부에서 초기화 해야 한다.

> 클래스를 final로 선언해서 오버라이드를 방지하라
* 클래스가 오버라이드되면 그 메서드들도 오버라이드될 수 있다. 가장 안전한 방법은 하위 클래스를 금지하는 것이다.

> 인수가 없는 생성자를 제공하지 말라
* 불변성 객체의 모든 상태는 생성자가 정해야 한다.
* 인수가 없는 생성자가 없으면 디폴트 생성자를 요구하는 JavaBeans 표준을 위반하게 된다는 점은 알아두자. 하지만 setXXX 메서드 때문에 자바빈스는 어쨌거나 불변형일 수가 없다.

---
### 7.2.1 아키텍처 - cont.
> 적어도 하나의 생성자를 제공하라
* 인수가 없는 생성자가 없으므로 객체에 상태를 더할 수 있는 마지막 기회를 제공해야 한다.

> 생성자 외에는 변이 메서드를 제공하지 말라
* 자바빈스식 setXXX 메서드를 제공하지 않아야 함
* 가변 객체의 참조를 리턴하지 않게 조심해야 한다. 객체 참조가 final이라고 해서 그 참조가 지정하는 것이 변이되지 말라는 보장은 없다. 따라서 getXXX 메서드가 리턴할 때는 반드시 객체 참조의 복제본을 리턴해야 한다.

---
### 7.2.1 아키텍처 - cont.
* 그루비는 [예제 7-4]처럼 불변성의 세부사항과 관련한 문법적 설탕을 제공한다.
* [예제 7-4 불변형 Client 클래스]
  ```
  @Immutable
  class Client {
      String name, city, state, zip 
      String[] streets
  }
  ```
  * @Immutable 애너테이션을 달면 이 클래스는 다음과 같은 특성을 갖는다.
  	* 이 클래스는 final로 선언된다.
  	* 모든 속성은 자동적으로 get 메서드가 딸린 비공개 필드를 가지게 된다.
  	* 이 속성을 업데이트하려고 하면 ReadOnlyPropertyExcetpion이 발생한다.
  	* 디폴트 equals(), hashcode(), toString() 메서드가 자동 생성된다.
  * @Immutable 애너테이션은 이 책에서 반복되는 테마, 즉 '런타임에 상세한 구현을 양도하라'를 잘 드러내 보여준다.

---
### 7.2.1 아키텍처 - cont.
* 객체-관계형 매퍼 같은 도구들은 대부분의 경우 불변 객체를 가정하기 때문에 가변 객체를 사용하면 비효율적이 되거나 작동하지 않는다. 따라서 함수형 패러다임이 광범위하게 사용되기 위해서는 기존의 시스템의 많은 부분에 큰 변화가 있어야 한다.
* 명령-쿼리 간 책임 분리(CQRS)처럼 기존의 인프라스트럭처를 활용하여 함수형 개념을 구현하는 아키텍쳐도 몇몇 존재한다.

---
### 7.2.1 아키텍처 - cont.
#### CQRS
* CQRS는 그레그 영(http://codebetter.com/gregyoung/)이 개념을 도입했고, 마틴 파울러가 영향력 있게 그 개념을 기술했다.(http://martinfowler.com/bliki/CQRS.html). 여기에는 여러 함수형 측면이 포함된다.
* 전통적인 애플리케이션 아키텍처에서는 애플리케이션의 모델 부분이 비즈니스 규칙이나 검증을 담당한다. 주로 모델 객체들이 내부적으로 또는 다른 논리 계층에서 자료 저장을 중재한다. 개발자는 읽기 쓰기의 혼합된 의미를 모델 전역에서 관리해야 한다. 이것이 시스템을 복잡하게 한다.
* CQRS는 **읽기**와 **명령** 부분을 분리함으로써 아키텍처의 일부를 단순화한다. CQRS에서는 모델(또는 특화된 컨트롤러)의 한쪽에서 데이터베이스 업데이트를 담당하고, 다른 부분에서는 자료 표현과 보고를 처리한다.

---
### 7.2.1 아키텍처 - cont.
* 그림 7-2 CQRS 아키텍처
![CQRS](http://martinfowler.com/bliki/images/cqrs/cqrs.png)
	* 개발자가 불변성을 가정할 수 있기 때문에 **쿼리** 쪽의 논리는 훨씬 단순하다.
	* **업데이트**는 다른 경로를 통해서 적용된다. 분리된 모델은 곧 분리된 논리적 프로세스를 의미한다.

---
### 7.2.1 아키텍처 - cont.
#### 최종 일관성
* 최종 일관성 분산 컴퓨팅 모델은 모델을 업데이트하는 데 정해진 시간 제한을 요구하지 않는다. 대신 새로운 업데이트가 없는 한, 최종적으로는 모델이 일관성을 갖추기만 하면 된다.
* 트랙잭션 모델이 ACID(원자성-Atomic, 일관성-Consistent, 고립성-Isolated, 지속성-Durable)에 의존하는 반면,
* 최종 일관성 모델은 BASE(기본 가용성-BAsically available, 부드러운 상태-Soft state, 최종 일관성-Eventual consistency)을 중요하게 여긴다.

---
### 7.2.1 아키텍처 - cont.
* 아키텍처는 항상 트레이드오프를 염두에 두어야 한다. CQRS로 인해 한 부분은 쉬워지지만 다른 부분은 복잡해진다. 예를 들어 한 덩어리인 데이터베이스를 사용하면 트랜잭션이 쉽다. CQRS를 사용하면 트랜잭션형보다는 최종 일관성 모델로 전환해야 할 것이다.
* 트랜잭션 모델을 포기하는 경우는 주로 애플리케이션을 확장해야 하기 때문이다. CQRS는 모든 애플리케이션의 상태 변화를 이벤트 스트림으로 보존해야 하는 **이벤트 소싱**과 같은 아키텍처 패턴에 아주 적합하다. **읽기**를 **변이**로부터 분리하면 논리적으로 단순해진다. **읽기**쪽에서는 모든 것을 불변형으로 처리할 수 있다.

---
### 7.2.2 웹 프레임워크
* 웹 프로그래밍은 함수형 프로그래밍에 잘 어울린다. 웹 전반을 요구를 응답으로 바꾸는 일련의 변형으로 볼 수 있기 때문이다.
* 모든 함수형 언어는 다양한 웹 프레임워크를 가지고 있다. 이들의 공통적인 특성은 다음과 같다.
	* 경로 설정 프레임워크
		* 현대 웹 프레임워크들은 경로 설정(routing) 라이브러리를 사용하여 경로 설정을 애플리케이션 기능으로부터 분리시킨다. 
	* 함수를 목적지로 사용
		* 웹상의 요구를 Request로 받아서 Response를 리턴하는 함수로 생각하면 이해가 쉽다.
	* 도메인 특화 언어
		* 마틴 파울러는 DSL을 좁은 문제 도메인에 적용되는 표현으로 제한된 프로그래밍 언어로 정의한다.
		* 루비 온 레일즈 웹프레임워크나 C#의 LINQ가 이런 접근법의 좋은 예이다. 
	* 빌드 도구와의 밀접한 연동

---
### 7.2.3 데이터베이스
* 데이터베이스를 업데이트 할 때마다. 예전 값은 없어지고 새 값으로 대체된다. 왜 이런 식으로 설계되었을까? 데이터가 증가하는 것을 억제하고 저장 장소를 극대화하기 위해서이다.
* 클로저 커뮤니키에서 상업적 NoSQL 데이터베이스에 처음으로 내놓은 [데이토믹](http://www.datomic.com/)은 아키텍처 전반을 뒤집으면 언어 설계자들이 함수형 개념을 어디까지 밀고 나갈 수 있는지를 알 수 있는 예이기 때문에 흥미롭다.
	* 데이토믹은 들어오는 모든 사실들에 시간을 붙여서 저정하는 불변성 데이터베이스이다.
	* 데이터 대신에 값을 저장함으로써, 데이토믹은 저장소를 상당히 효율적으로 사용한다.
	* 데이토믹은 정보에 시간의 개념을 첨부하여 사실이 항상 적절한 문맥과 연결되게 하였다.

---
### 7.2.3 데이터베이스 - cont. 
* 이러한 설계에서 몇 가지 흥미로운 결과가 나왔다.
	* 모든 스키마와 데이터의 변화를 영원히 기록하기
	* 읽기와 쓰기의 분리
		* 데이토믹의 아키텍처는 자연스럽게 읽기와 쓰기 작업을 분리한다. 업데이트 쿼리 때문에 지연되는 일이 결코 없다. 즉 데이토믹은 내부적으로는 CQRS 아키텍처이다. 
	* 이벤트 주도 아키텍처를 위한 불변성과 타임스탬프
		* 이벤트 주도 아키텍처는 애플리케이션 상태 변화를 이벤트 스트림으로 저장
		* 모든 정보를 타임스탬프와 함께 저장하는 데이터베이스가 여기에 적합. 이런 데이터베이스는 되감기와 재생 기능이 가능
