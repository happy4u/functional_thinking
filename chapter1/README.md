# Functional Thinking (함수형 사고)

---

# 1 왜(Why)

* 전혀 새로운 프로그래밍 패러다임의 문제점은 새로운 언어를 배우는 것이 아니다
* 문법은 한낱 세부사항일 뿐이다. 어려운 점은 바로 다른 방식으로 사고하는 법을 배우는 것이다.
* 스칼라나 클로저에 관심이 없고, 지금 사용하는 언어로 앞으로 평생 개발해도 상관없다고 생각하더라도, 언어는 당신 발밑에서 점점 함수형으로 바뀔 것이다. 사용하는 언어에 나중에 함수형 패러다임이 도입되었을 때(이것은 필연이다) 잘 사용하려면, 지금 배워야 한다.
* 이제 왜 모든 언어가 점차적으로 함수형이 되어가는지를 알아보자

---
## 1.1 패러다임 전환
* 1967년 시뮬라 67이라는 최초의 객체지향 언어가 만들어졌지만, 1983년 C++가 보편화된 후에야 주류가 되었다.
* 함수형 프로그래밍은 객체지향과 개념적으로 같은 궤도를 따른다. 지난 이 삼심년간 학계에서 연구되었고, 현대 프로그래밍 언어들에 조금씩 도입되어왔다. 그렇다고 새로운 문법만 추가한다고 해서 개발자들에게 새로운 사고방식까지 알려줄 수는 없다.

*이 챕터의 나머지는 java를 이용해 절차적 방식과 함수형 방식을 이용한 예제의 비교내용*

---
## 1.2 언어 트렌드에 발맞추기
* 주요 언어들이 변화하는 것을 보면, 모두 다 함수형 기능을 더하고 있다.
  * 그루비 : 메모제이션* 같은 고급 기능을 포함한 함수형 기능 추가
 > 메모이제이션 : 함수의 연산결과를 저장해두었다가, 같은 입력이 주어지면 연산을 하지 않고 리턴하는 최적화 기법.
  * Java 8 : 람다블록 도입
  * javascript : 이미 많은 함수형 언어 기능 포함
  * C++ : 2011년 람다 블록 추가


---
## 1.3 언어/런타임에 제어를 양도하기
* 점점 언어들은 고수준의 추상화되는 방향
* 시간이 갈수록 개발자는 지루한 일들을 언어나 런타임에 점점 더 맡기게 된다.
* 애플리케이션을 만들면서 직접 메모리를 제어하지 않는다는 것을 조금도 후회하지 않는다. 그런 일에 무관심해졌기 때문에 좀 더 중요한 문제들에 집중할 수 있다.
* 자바가 메모리 관리 작업을 쉽게 해줬다면, **함수형 프로그래밍 언어는 다른 빌딩블록들을 고수준 추상적 개념으로 대체해준다.**

---
## 1.4 간결함 (1/3)
* '레거시 코드 활용 전략'의 저자인 마이클 페더스는 함수형과 객체지향형 추상화의 차이점에 대해서 트위터에 140자로 다음과 같이 썼다
> 객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다.

* 객체지향 프로그래밍의 캡슐화, 스코핑, 가시성 등의 메커니즘은 상태 변화를 누가 볼 수 있는지에 대한 세밀한 제어를 위해 존재한다. 상태에 쓰레드까지 곁들이면 골칫덩이는 더욱 커진다. 이러한 메커니즘이 바로 페더스가 말하는 '움직이는 부분'이다.
* 함수형 언어는 이런 가변 상태를 제어하는 메커니즘을 구축하기보다, 그런 '움직이는 부분'을 아예 **제거**하는 데 주력한다. 언어가 오류가 발생하기 쉬운 기능을 적게 노출하면 개발자가 오류를 만들 가능성이 줄어든다는 이론에 따른 것이다.


---
## 1.4 간결함 (2/3)

* 함수형 프로그래밍 언어는 최적화된 동작으로 몇몇 자료구조(list, set, map)를 이용하는 방식의 재사용을 선호한다. 개발자가 이런 방법을 잘 사용하려면, 특정 용도로 정의된 방법에 자료구조와 고계함수(**higher-order function이란, 함수를 다루는 함수를 뜻한다**)를 함께 넣어야 한다.
* 함수 수준의 캡슐화는 모든 문제에 대한 새로운 클래스 구조를 구축하는 것보다 세분화되고 기초적인 수준에서 재사용을 가능하게 한다.

> 고계함수 (higher-order function)
>> 함수를 다루는 함수를 의미함.
>> 다음 중 한가지 이상을 만족하는 함수
>> 1. 파라미터로 함수를 받을 수 있다.
>> 2. 결과값으로 함수를 리턴한다. 

---
## 1.4 간결함 (3/3)
* 자바 세계에는 자체적으로 내부 자료구조를 가진 수십 개의 XML 라이브러리가 있다 **vs** 클로저 세계에는 한 단계 높은 추상화의 장점이 이미 부각되고 있다. 클로저의 최근 라이브러리들은 map 함수를 재구현하여 자동 병렬화가 가능해졌다.
* 함수형 개발자는 적은 수의 자료구조와 그것들을 잘 이해하기 위한 최적화된 방법을 만들기를 선호한다. **vs** 객체지향형 개발자는 항상 새로운 자료구조와 그것에 부착된 메서드를 만든다. 클래스와 통신 메세지를 만드는 것이 지배적인 객체지향 패러다임이다. 모든 자료구조를 캡슐화하면 메서드 수준의 재사용보다는 큰 프레임워크 스타일의 재사용을 선호하게 된다.
*나머지 부분은 Apache Commons StringUtils.indexOfAny() vs firstIndexOfAny of scala에 대한 내용*

