<!-- $size: 16:9 -->
# 6 전진하라(Advance)
* 사용하는 언어의 주된 패러다임이 객체지향이라면, 모든 문제의 해법을 객체지향적으로 찾게 마련이다.
* 하지만 대부분의 현대 언어들은 다중 패러다임을 갖고 있다. 다시 말하자면 이 언어들은 객체지향형, 메타객체형, 함수형 등의 패러다임을 다 지원한다.
* 문제에 적합한 패러다임을 사용하는 법을 배우는 것이 더 좋은 개발자로 진화하는 길 중의 하나이다.

---
## 6.1 함수형 언어의 디자인 패턴
* 함수형 언어계의 어떤 이들은 디자인 패턴이 개념 자체에 결함이 있기 때문에 함수형 프로그래밍에서는 필요가 없다고 주장한다. 이런 주장은 패턴의 사용보다는 의미론에 국한된 것이다.
* 함수형에서는 빌딩블록과 문제의 접근 방법이 다르기 때문에, 전통적인 GoF 패턴들 중의 일부는 사라지고, 나머지는 근본적으로 다른 방법으로 같은 문제를 풀게 된다.

* 함수형 프로그래밍에서는 전통적인 디자인 패턴들이 다음과 같은 세 가지로 나타난다.
	* 패턴이 언어에 흡수된다.
	* 패턴 해법이 함수형 패러다임에도 존재하지만, 구체적인 구현 방식은 다르다.
	* 해법이 다른 언어나 패러다임에 없는 기능으로 구현된다. (예를 들어 메타프로그래밍을 사용한 해법들은 깔끔하고 멋있다. 이런 해법은 자바에서는 불가능하다.)


---
## 6.2 함수 수준의 재사용
* 구성(Composition)은 함수형 프로그래밍 라이브러리에서 재사용의 방식으로 자주 사용된다. 함수형 언어들은 객체지향 언어들보다 더 큰 단위로 재사용을 한다. 그러기 위해서 커스터마이즈되는 공통된 작업들을 추출해낸다.
* [예제 2-12](https://github.com/happy4u/functional_thinking/blob/master/chapter2/2.2.3_ex_2-12.java)의 목록을 필터하는 함수형 접근 방법은 모든 함수형 언어나 라이브러리에 흔하게 존재한다.
* filter() 메서드에서처럼 코드를 매개변수로 전달하는 기능은 코드 재사용의 다른 접근 방법을 제시해준다. 전통적인 디자인 패턴을 사용하는 객체지향의 관점에서 볼 때는 클래스나 메서드를 만들어서 문제를 푸는 방식이 더 편해 보일 수도 있다.
* 예를 들어 클로저를 지원하는 언어에서는 커맨드 디자인 패턴이 필요 없다. 궁극적으로 디자인 패턴의 존재 목적은 언어의 결함을 매꾸기 위함일 뿐이다. 물론 디자인 패턴은 실행취소 같은 다른 상황에도 유용하다. 하지만 이 패턴은 실행 가능한 코드를 메서즈에 전달하는 방법으로서 주로 사용된다.

---
### 6.2.1 템플릿 메소드
* [예제 6-1 템플릿 메서드의 '표준' 구현](https://github.com/happy4u/functional_thinking/blob/master/chapter6/6.2_ex_6-1.groovy)
	* process() 메서드는 checkCredit(), checkInventory(), ship()에 의존한다.

* [예제 6-2 일급 함수를 사용한 템플릿 메서드](https://github.com/happy4u/functional_thinking/blob/master/chapter6/6.2_ex_6-2.groovy)
	* [예제 6-2]에서 알고리즘의 각 단계는 클래스에 할당할 수 있는 성질에 불과하다. 이것이 상세한 구현 방법을 언어의 기능으로 감추는 일례다.(danny's - 개인적으로 잘 이해는 안감)


---
### 6.2.2 전략
* [예제 6-4 전략 패턴을 사용한 두 숫자의 곱셈](https://github.com/happy4u/functional_thinking/blob/master/chapter6/6.2_ex_6-4.groovy)
	* 두 수의 곱을 인터페이스로 정의하고, 곱셈과 덧셈을 각각 사용한 두 가지 구체 클래스를 구현

* [예제 6-5 곱 전략 테스트하기](https://github.com/happy4u/functional_thinking/blob/master/chapter6/6.2_ex_6-5.groovy)
* [예제 6-6 보일러플레이트 코드를 제거한 지수 계산 테스트](https://github.com/happy4u/functional_thinking/blob/master/chapter6/6.2_ex_6-6.groovy)
	* [보일러플레이트](http://terms.co.kr/boilerplate.htm) : 원 뜻만 보면 재사용 가능한 좋은 의미 같지만, 여기서는 java에서 getter, setter만드는 것과 같은 코드들을 지칭함
	* 코드 블록을 일급함수로 사용하여, 이전 예제에서의 보일러플레이트 코드의 대부분을 제거할 수 있다.
* 전통적인 방법은 각 전략에 이름과 구조를 정해야 하고, 이런 방법이 바람직한 경우도 있다. 전통적인 방법을 사용하면 거기에 따르는 제약조건을 어길 수가 없지만, [예제 6-6]의 코드에는 개발자가 임의로 그런 제약을 더해서 안정성을 향상할 수 있었다.
* 이것은 함수형 프로그래밍과 디자인 패턴의 논의가 아니라 **동적 언어와 정적 언어의 논의**라 하겠다.

---
### 6.2.3 플라이웨이트 디자인 패턴과 메모이제이션

